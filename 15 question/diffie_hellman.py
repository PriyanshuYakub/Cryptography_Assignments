import random
import math
from math import gcd

def getModInverse(n,b):
    r1 =n
    r2 = b
    t1 = 0
    t2 = 1
    while(r2>0):
        q = int(r1/r2)
        r = r1-q*r2
        r1 = r2
        r2 = r
        #inverse part
        t = t1- q*t2
        t1 = t2
        t2 = t
    #to maintain +ve inverse value and that it is in Zn 
    if(t1<0):
        t1 = n +t1
    return t1


def Divisibility_test(n):
    r = 2
    while(r< math.sqrt(n)):
        if(n%r==0):
            return False
        r += 1
    return True

#Fermats prime gen and other functiones mixed
def PrimeGen():
    while True:
        n = random.randint(1,100)
        fn = 2*n + 3
        gn = n**2 + 1
        hn  = 2**n + 1
        if(Divisibility_test(hn)):
            return hn
        elif(Divisibility_test(gn)):
            return gn
        elif(Divisibility_test(fn)):
            return fn
        else:
            print("prime not found repeat loop")



#function to generate primitive roots of given prime number
def primRoots(modulo):
    required_set = {num for num in range(1, modulo) if gcd(num, modulo) }
    return [g for g in range(1, modulo) if required_set == {pow(g, powers, modulo)
            for powers in range(1, modulo)}]


def Calculate_R(n,g,p):
    return pow(g,n)%p



def Calculate_SKey(R,n,p):
    return pow(R,n)%p



def value_K(g,x,y,p):
    return pow(g,x*y)%p


def main():

    p = PrimeGen();
    prim_root_list = []
    while(True):
        prim_root_list = primRoots(p)
        if prim_root_list != [] :
            break
        else:
            p = PrimeGen()
            
    g = random.choice(prim_root_list)
    print("Public: value of p = ",p," and value of g = ",g)
    

    Alice_x = random.randint(1,p-1)
    print("Random number x chosen by Alice: ", Alice_x)

    
    Bob_y = random.randint(1,p-1)
    print("Random number y chosen by Bob: ", Bob_y)


    R1 = Calculate_R(Alice_x, g, p)
    R2 = Calculate_R(Bob_y, g, p)

    print("Alice sends ", R1, "to Bob.")
    print("Bob sends ", R2, "to Alice.")

    #Alice calculates symmetric key
    Alice_key = Calculate_SKey(R2,Alice_x,p)
    print("Symmetric key Alice generated by using Bob's number: ", Alice_key)

    #Bob calculates symmetric key
    Bob_key = Calculate_SKey(R1,Bob_y,p)
    print("Symmetric key Bob generated by using Alice's number: ", Bob_key)
    
    K = value_K(g,Alice_x,Bob_y,p)

    #check if all the key vlues are same
    if K == Alice_key and K == Bob_key:
        print("Diffie-Hellman Key Agreement -- Successful")
    else:

        print("Diffie-Hellman Key Agreement -- Unsuccessful")



main()